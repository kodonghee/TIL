## MSA 구성요소와 아키텍쳐패턴
### MSA - 구성요소

#### 이벤트기반 통신
- 마이크로서비스는 이벤트 또는 메시지 브로커를 통해 비동기적으로 통신하는 것을 권장. 이를 통해 서비스간 느슨한 결함과 유연성을 확보.
#### 로깅 및 모니터링
- 모니터링 및 로깅 도구는 마이크로서비스의 성능추적 및 가용성을 확보, 유지하는데 매우 중요한 구성요소. **분리된 서비스들 로그의 통합 및 지표들의 정의**가 중요
- 사용자들의 활동에 대한 분석과 활용, 시스템 동작에 대한 인사이트를 제공
- **서비스 주요 메트릭 모니터링 - Prometheus와 Grafana**
	- '결제 처리 서비스'의 응답 시간을 모니터링하고 성능문제 진단.
- **중앙집중식 로깅 - ELK Stack(Elasticsearch, Logstash, Kibana)**
	- 시간대별 주문량 추이 등의 패턴분석, 빅데이터 활용
#### 지속적인 통합 및 배포 - CI/CD
- 마이크로서비스 아키텍처는 빈번한 변경과 그에 따른 즉각적인 반영(배포)를 요구함
- CI/CD 파이프라인은 마이크로서비스의 배포와 테스트를 자동화하여 신속한 개발과 지속적인 배포를 보장.
#### 컨테이너화, 오케스트레이션
- 확장 가능하고 탄력적인 방식으로 마이크로서비스를 **패키징**, 배포 및 **관리**하기 위해 Docker와 같은 **컨테이너**와 Kubernetes와 같은 오케스트레이션 도구가 사용됨.
- Kubernetes를 사용하게 되면 클러스터의 여러 노드에 걸쳐 "상품 카탈로그 서비스"의 여러 인스턴스를 자동으로 배포, 관리하여 고가용성을 보장.
#### 요약
- MSA의 구성 요소들은 서비스 어플리케이션 관련 요소를 포함해서 인프라 환경, 배포 및 모니터링과 같은 서비스 운영 전반에 걸쳐 다양한 요소들을 포함
- 구성요소는 각각의 관련된 아키텍처 패턴을 가지고 있으며 제공하려는 서비스의 성격에 따라 적합한 패턴들과 기술들을 적용하기 위해서는 구성요소에 대한 이해가 필수

### MSA - 아키텍처 패턴

#### 아키텍처 패턴을 알아야 하는 이유
- 아키텍처 패턴: 문제 영역에 대한 검증된 유용한 해법
- **MSA를 도입하려면 그 아키텍처의 복잡성으로 인해 여러가지 문제 영역에 부딪히게 된다.**
	- 분산환경에서의 서비스 구성 시 발생 가능한 여러 문제 영역 존재
	- ex) 시스템 복잡도 증가, 장애 전파, 성능 이슈, 데이터정합성 등
- 도서: 마이크로 서비스 패턴
#### 아키텍처 유형별 패턴
- MSA 외부 아키텍처
	- 플랫폼 패턴
	- 애플리케이션 관계 패턴
- MSA 내부 아키텍처
#### 주요 아키텍처 패턴
##### 1. Service Registry/Discovery 패턴
* Registry: 마이크로서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관 및 제공하는 기능을 수행
* Discovery: 서비스 클라이언트가 다른 서비스를 호출할 때 서비스의 접속 주소를 알아낼 수 있는 기능이 필요함
* 클라우드 환경에서 서비스가 Scale-out 등을 통해 동적으로 생성 또는 서비스 IP가 동적으로 변경될 때, 서비스들은 이 패턴을 통해 환경의 변화 없이 실행 가능
* Client-Side Discovery
	* client가 service registry에서 서비스의 위치를 찾아서 호출하는 방식
	* client에서 라우팅 및 로드 밸런싱 수행 ex) Spring Cloud Netflix (Eureka, Ribbon)
* Server-Side Discovery	
	* 호출이 되는 서비스 앞에 일정의 Proxy(로드 밸런서)를 넣는 방식
	* Client가 로드 밸런서를 호출하면 로드 밸런가 Service registry로부터 등록된 서비스의 위치를 받아 이를 기반으로 라우팅하는 방식
	* 가장 흔한 예로는 AWS의 ELB
##### 2. API Gateway 패턴
* 클라이언트와 서비스 사이에 프록시처럼 위치하여, 클라이언트로부터 유입되는 API 요청을 받아 적절한 서비스로 라우팅 하는 역할을 담당.
* 클라이언트가 접근 가능한 단일 진입점(Single Entry Point)을 제공하기 때문에 그 특성으로 인한 여러 유용한 기능을 제공할 수 있다.
* 제공 기능: 요청 라우팅, 인증 및 승인, 프로토콜 변환, 로드 밸런싱, 요청 변환, 응답캐싱, 로깅 및 모니터링
* 도입 필요성: 보안, 트래픽 관리, API Composition, 그외 다양한 문제 해결
##### 3. 외부 구성 저장소 패턴
* 마이크로서비스들이 필요로 하는 애플리케이션 구성 정보를 일관되게 관리하기 위한 방법
* 구성정보는 외부 저장소에서 일괄적으로 관리, 서비스 코드와 분리한다.
* 클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안 된다는 원칙. 
	- :point_right: 설정정보는 외부저장소에 관리, 각 서비스가 변경과 배포절차 없이 일괄적으로 외부에서 설정정보를 주입받을 수 있도록 처리
##### 4. 중앙화 로그 집계 패턴
* 각 서비스가 생성하는 로그를 수집 및 집계하여 중앙화된 시스템에서 제공하는 것이 중앙화된 로그 집계 패턴
	###### 중앙화된 로그 집계가 필요한 이유
	* 분산환경에서의 서비스 운영과 모니터링을 위해서는 **로그의 통합**이 매우 중요
* Elastic Search
* Logstash
* Kibana
* AWS CloudWatch
	- AWS에서 EC2, ECS, Elastic Beanstalk에서 실행되는 어플리케이션의 로그를 수집하여 시각화 제공
	- 실시간 로그 데이터 통합 및 수집
	- 로그 검색기능 제공 - CloudWatch Log Query
	- 주요 임계치 및 메트릭 설정 지원
	- 시각화 및 Alarm 등의 Notification
##### 5. CQRS(Command-Query Responsibility Segregation) 패턴
* 명령과 조회 책임의 분리를 의미
* 시스템의 읽기 및 쓰기 작업을 명령 모델(업데이트용)과 쿼리 모델(읽기용)의 두 가지 모델로 분리하는 패턴 
* Database 분리기반 CQRS
	- 명령/조회를 위한 **Database를 분리**하고 별도의 Message Broker를 통해 Data 동기화를 처리하는 방식
	- **결과적 일관성**을 지원
	- 동일 Database 사용에 따른 성능 문제를 해결 가능
	- Data 동기화 처리를 위한 **Message Broker 가용성과 신뢰성**이 보장되어야함.
	- 물리적으로 2개의 데이터베이스를 사용하여 읽기 및 쓰기 데이터베이스를 분리하는 것이 가장 이상적
	- 읽기 집약적인 애플리케이션인 경우 쿼리에 최적화된 사용자 정의 데이터 스키마를 별도로 구성
* Query Service에는 No-sql 사용
* 사용자가 주문을 생성하거나 업데이트할 때는 관계형 쓰기 데이터베이스(RDMS) 적용
* 사용자가 주문이나 주문 내역을 조회할 때는 비관계형 읽기 데이터베이스(No-sql) 적용
##### 6. 마이크로 서비스 통신 패턴
* 서비스 간의 효율적인 커뮤니케이션을 위한 통신 패턴
* 마이크로서비스의 통신패턴은 크게 요청과 응답의 즉시성에 따라 동기식과 비동기식으로 구분할 수 있음
* 마이크로 서비스를 구성함에 있어 통신 패턴의 선택은 애플리케이션의 특정 요구 사항과 지연시간(latency)과 확장성(Scalability) 간의 원하는 절충점에 따라 달라짐
* 빠른 응답을 얻는 것과 시스템이 많은 작업을 처리할 수 있는지 확인하는 것 사이에서 적절한 균형이 필요
* 동기: 요청/응답
	- 블로킹, 서비스가 서로 강하게 결합되는 방식
	- 결제서비스, 인증서비스, 재고관리 서비스 등
* 비동기: 비동기 요청/응답, 단방향 알림
	- 넌블로킹, 서비스가 서로 느슨하게 결합되는 방식
	- 이벤트 알림서비스, 이미지, 파일 프로세싱 등
* HTTP(REST)
	- 가장 대중적인 서버간 요청-응답 통신 방식, 단방향 통신
* gRPC (Google Remote Procedure Call)
	- 구글이 최초로 개발한 오픈 소스 원격 프로시저 호출 시스템, 양방향 통신
* GraphQL
	- 클라이언트 쿼리언어, End-Point가 하나만 존재

# MSA 주요 적용사례 및 장단점
## MSA 주요 적용사례
#### 글로벌 혁신 기업의 MSA 도입과 사례를 통해 그 배경과 과정, 결과 등 실제 MSA 도입에 필요한 **다양한 인사이트**를 얻기 위함
### Netflix
* 넷플릭스의 MSA 전환은 '마이크로서비스'라는 용어가 유행하기 전인 2008년에 시작
* **우리가 알고 있는 지금의 스트리밍 서비스는 2007년에 모놀리식 시스템으로 시작**
* 2008년, 대규모 장애로 인해 서비스 중단
  * 3일 동안 회원들에게 DVD를 배송하지 못하는 사태 발생 (DB 장애)
  * 온라인 DVD 대여 사이트의 모든 서비스가 3일 간 정지
  * **모놀리식 서비스 -> 마이크로 서비스 아키텍쳐 전환 계기**
* Netflix는 모든 시스템을 AWS Cloud로 마이그레이션 하기로 결정
* Big Bang이 아닌 단계적, 점진적 마이그레이션 진행
* 2009년에 시작한 시스템 재설계 및 실행이 2011에 완료
> 2009년 모놀리식 아키텍처를 마이크로서비스로 리팩토링하는 '**점진적인 프로세스**'를 시작함
>> * 고객 비대면 플랫폼인 movie-coding-platform을 AWS 클라우드 서버로 이관
>> * 2년 동안 고객 대면 시스템 전체를 마이크로서비스로 전환하는 작업을 진행
>> * 실질적인 모든 서비스의 마이크로서비스 전환과 클라우드 이관은 2016년까지 진행 (7년의 기간)

* 2013년까지 Netflix의 API 게이트웨이는 **500개 이상의 클라우드 기반 마이크로서비스**와 연결
* 일일 **20억 건의 API 요청**을 처리
* 2017년에는 **700개 이상의 마이크로서비스로 구성된 아키텍처를 구축**함
* 정말 중요한 건 이런 MSA 전환과정에 겪은 시행착오 경험의 결과로 Netflix OSS가 만들어짐
* 마이크로 서비스의 기술 발전을 주도, 많은 기업들이 도입 성공사례가 되는 토대

### Amazon (AWS)
* 2001년까지 Amazon.com은 단일 모놀리식 시스템 (일반 온라인 도서 쇼핑몰)
* 서비스가 확장됨에 따라 빠르게 개발되는 코드가 운영에 배포되는 데 오랜 시간이 걸리게 됨
* 시스템을 분해하여 독립적인 서비스들의 집합으로 재설계
* **SOA (Service Oriented Architecture)의 개념이 시작되고 지금의 MSA 시초가 됨**
* **Amazon 클라우드 (AWS)의 탄생**

### 제프 베조스 (Jeff Bazos's, 아마존 CEO) Mandate
* 모든 팀은 해당 팀의 기능 및 데이터를 Service Interface를 통해서만 노출해야 한다.
* 다른 팀의 기능/데이터를 사용하려면 Network를 통한 Service Interface를 호출해야 한다.
* Service Interface 기술을 상관하지 않겠다. (HTTP, ... etc.)
* 서비스의 확실한 분리 -> 단일 책임 원칙, 자율성 부여

### Amazon의 MicroService - 상징적인 지표
* 평균적인 서비스 배포 간격: 11.6초
* 1시간에 최대 배포 수: 1,079
* 단일 배포를 받는 평균 호스트 개수: 10,000
* 단일 배포를 받는 최대 호스트 개수: 30,000

> 배포의 횟수 = 고객에게 주는 서비스 가치의 전달 속도

* **수 천개 팀 (자율적 DevOps팀) + 마이크로서비스 아키텍처 + 지속적 배포 (CD) + 다양한 개발환경**
* **연간 5천만회 배포 (2014년)**

### Uber
#### 차량 공유 (Car Sharing) 서비스 기업
* Uber도 처음에는 모놀리식 시스템으로 시작
* Uber는 다른 기업과 다르게 서비스가 출시된 지 얼마 지나지 않아 바로 모놀리식 시스템으로 인한 한계에 직면 (폭발적 성장)
* 가장 큰 문제점은 서비스의 글로벌 확장을 위한 프로그램 변경, 배포의 어려움
> 당시 우버가 직면했던 가장 심각했던 문제점
* 하나의 새로운 기능을 적용하기 위해 다른 기능 모두를 재구성하고 재배포해야 함
  * 과금, 드라이버 서비스의 경우 글로벌 확장 시의 잦은 변경이 발생 (서로 다른 정책, 법률, 규제 등)
* 단일 레파지토리에서 다수의 개발자 (글로벌)가 여러 작업을 동시에 진행하는 데 어려움
* 신규 버전의 글로벌 배포 시 동시 배포가 필요한 경우 각 글로벌 환경에 따른 인프라 확장이 불가한 상태
* Netflix와 동일하게 클라우드로 이관하면서 서비스를 점진적으로 분리함
* API Gateway 도입으로 서비스의 연결
* 서비스 분리와 같이 개발 조직 분리 -> 서비스 도메인의 전문가 -> 빠른 문제 해결, 개발 생산성, 품질 개선
* 글로벌 표준 개발 - 마이크로 서비스의 품질, 성능 지표 수립

### 국내 사례
* 배달의 민족 - [우아콘2020] 배달의 민족 마이크로서비스 여행기
* 11번가 Spring Cloud 기반 MSA로의 전환 - 지난 1년간의 이야기
* PAYCO 쇼핑 MSA 전환기

## MSA 장단점
### 모놀리식 아키텍처의 한계
> **비즈니스의 성장으로 서비스 규모가 커질 때 한계가 나타남**
* 어플리케이션 복잡성 증가로 인한 개발 속도 저하
* 그로 인한 배포 시간의 증가
* 또 그로 인한 오류 발생의 증가 (Side Effect, 버그의 재생산) - SRP의 부재
* 부분적 확장(Scale-out)의 어려움, 장애의 반복

### 모놀리식 vs MSA
* 모놀리식
  * 장점
    * **단순성**
      * 단일 배포 단위 
      * 통합 데이터 관리
  * 단점
    * 제한된 확장성, 전체 배포
    * 복잡석 (단일코드의 복잡성)
    * 개발 속도 저하, 배포 시간
* MSA
  * 장점
    * **확장성/유연성**
      * 독립적인 확장
      * 더 빠른 개발
  * 단점
    * 분산된 복잡성
    * 운영 오버헤드 증가
    * 데이터 관리 과제

### MicroService Pros
* 독립서비스 변경이 용이, 다른 서비스에 미치는 영향 최소화
* 개별 배포, 빠른 배포
* 부분확장으로 인한 비용
* 서비스별 효율적인 자원사용
* **개발조직과 전사 조직문화에 영향 (애자일)**
* 빠른 의사결정, 독립적인 테스트

### MicroService Cons
* 분리된 서비스 간의 커뮤니케이션 비용 - 개발 + 성능 (응답속도)
* 분산 트랜잭션 처리 비용 (데이터 동기화)
* 배포의 규모, 관리 포인트의 증가 - 통합 모니터링 및 운영 비용

### MicroService의 역할과 요구되는 것
* MSA가 단순히 모놀리식 애플리케이션을 분해하는 것 이상의 역할
* MSA는 단순한 기술적 선택이 아니라 **조직 및 문화적 변화**를 수반
* 마이크로서비스 간 **커뮤니케이션의 중요성**과 API 및 프로토콜의 역할
* DevOps 및 애자일 관행을 포함하여 MSA를 성공적으로 도입하는 데 필요한 **문화적 변화**
* MSA에 **적합한 도구**와 **기술을 선택**하는 것의 중요성

### MicroService의 도입
* **모놀리식으로 관리하기에 특별히 복잡한 시스템을 운영할 상황이 아니면 마이크로서비스는 고려할 필요조차 없다**
> **마이크로서비스를 사용할지 여부의 핵심은 고려 중인 시스템의 복잡성이다.**

### Monolith vs MicroService
* 덜 복잡한 시스템의 경우, MSA를 관리하는 데 필요한 baggage로 인해 모놀리스보다 생산성이 더 떨어짐
* 복잡성이 증가하면 모놀리스의 생산성은 급격히 저하
* **하지만 팀의 실력이 모놀리스/MSA 선택보다 더 중요함**

## 현대 아키텍처의 경향과 방향성
### 리액티브 선언 (Reactive Menifesto)
* 2014년 요나스 보네르 등이 선언한 리액티브 선언문
* 현대 애플리케이션이 갖춰야할 바람직한 4가지 속성들 제시
* 이러한 요건을 만족하는 시스템을 **리액티브 시스템**으로 정의
* 응답성 (Responsive): 사용자에게 신뢰성 있는 빠른 응답을 제공하는 것을 의미
* 탄력성 (Resilient): 장애가 발생하거나, 부분적으로 고장이 나더라도 전체가 고장나지 않고 빠르게 복구하는 능력
* 유연성 (Elastic): 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것을 의미하며, 시스템의 사용량에 비례하여 자원을 늘리거나 줄이는 능력
* 메시지 기반 (Message Driven): 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향

* **급변하는 현재의 비즈니스 환경에 적응할 수 있는 시스템을 요구하는 것으로, 시스템 자체가 언제든지 유연하고 빠르게 대응할 수 있어야 하기 때문**
### 현대의 백엔드 개발자에게 요구되는 능력
* **백엔드 언어 스킬 (Java)에 대한 영역 뿐만 아니라 다양한 영역(DevOps, Cloud, CI/CD 등)에 대한 이해도와 일정 수준 이상의 지식을 요구**
* **오픈 소스 기술에 대한 관심과 활동**

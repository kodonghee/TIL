## Event Driven MicroService
### Event Driven?
* 시스템 내 외부에 발생한 주목할 만한 상태의 변화에 기반한 동작
* Event Driven 아키텍쳐는 특정 서비스에서 다른 서비스가 관심을 가질 수 있는 작업을 수행할 때 해당 서비스는 이 작업을 이벤트로써 이벤트 스토어(메세지 Queue)에 기록
* 다른 서비스는 기록된 이벤트들을 구독, 자신들의 작업을 수행

### 왜 Event Driven?
* 느슨한 결합이 가능하므로 분산 시스템, 마이크로서비스 간 협업 관계에 있어 상호 의존성을 배제할 수 있음

### 이벤트 처리 방식
* 대기열(Queue) 방식 - Point to Point
    * 대기열 방식은 최초 Consumer가 가져간 베세지는 다른 소비자가 가져갈 수 없음 (소비의 개념)
* 토픽(Topic) 방식 - Pub-Sub
    * Pub-Sub은 모든 구독자(subscriber)들이 메세지를 최소 1번 이상(복제본) 가져갈 수 있음

### 이벤트를 저장, 소비하는 방식
* 대기열 방식 - Point to Point
    * 여러 작업자에게 작업을 분산시켜야 하고 중복 처리를 피하려는 시나리오에 유용
    * ex) 주문처리 마이크로서비스
* 토픽 방식 - Pub-Sub
    * 동일한 유형의 이벤트에 관심이 있는 여러 소비자에게 이벤트를 브로드캐스트해야 할 때 적합
    * ex) 소셜 플랫폼의 구독 서비스
* 선택기준의 핵심
    * 모든 consumer들이 모든 메세지를 전부 수신해야 하는가?

### 대표적인 메세지 브로커
* Rabbit MQ (Active MQ)
    * 강력한 메세지 라우팅 기능, Queue의 다양한 옵션 설정
* Amazon SQS / SNS
    * 메세지 브로커를 설정할 필요 없는 단순 대기열과 주제 서비스 (SaaS)
    * 단순히 Queue 용도로만 사용할 경우 적절한 대안이 될 수 있음
* Apache Kafka
    * 범용 메세지 브로커 중에서는 가장 뛰어난 성능, 대표적인 Pub-Sub(Topic) 기반 기술
    * 최소 1번의 메세지 전송 보장, 파일 기반 메세지 로그 저장

### 배민의 Event Driven 적용 예시 - AWS SQS + AWS SNS의 조합

### Zero-Payload 방식
1. 이벤트 전송 (변경에 대한 Notification, key 정보)
2. 이벤트 수신
3. 변경 내용 조회 (API)
* Zero-payload 방식은 이벤트 전송 처리 방식의 하나
* 메세지 발행자는 변경 시 모든 데이터를 다 보낼 수 없음 (필요없음) - 구독자마다 요구하는 dataset은 다 다름

### MSA를 도입한 이후 직면하게 되는 문제점
* 개발 복잡도와 숙련도
* 통합 테스트 및 디버깅의 어려움
* 배포의 복잡도
* **분산된 서비스 간 트랜잭션 처리 및 데이터 동기화**
* Database Per Service 을 기반으로 한 **분산된 서비스 간 트랜잭션 처리 및 데이터 동기화**는 잘 처리되고 있는가?

#### 분산된 데이터 베이스의 트랜잭션의 관리
* 마이크로서비스 아키텍처에서 고려해야 하는 여러 가지 요소 중에서 많은 가장 어려운 부분
* 기존의 단일 DBMS를 활용 가능했던 **ACID 트랜잭션**에 따른 데이터 무결성 보장은 MSA에서 서비스, DB가 분리됨으로 인해 더는 달성 불가

### Event Driven MicroService
* EDM은 MSA가 적용된 시스템에서 **이벤트** 발생 시 해당 **이벤트 로그**를 보관하고 서비스들은 이를 기반으로 동작하며, **비동기 통신**을 통해 **시스템 내 통합**을 수행하는 아키텍처
* 이벤트 - 상태의 변경, 서비스의 의미있는 변화
* 이벤트 로그의 보관 - 상태변경의 누적, 생성된 이벤트는 반드시 보관되어야 함.
* 비동기 통신 - 서비스 간 이벤트 로그의 전달 및 수신, MQTT, AMQP 등의 메세징 프로토콜 기반 기술 사용

### 이벤트-주도 (Event-Driven) 데이터 관리
1. EDM에서 이벤트는 **데이터의 생성, 변경, 삭제**로 정의
2. 이벤트가 발생하면 **이벤트 스토어**에 보관하고 **메시지 큐**를 통해 발행
3. 해당 이벤트에 관심이 있는 서비스에서 구독 후 정해진 biz.logic을 수행, **이벤트 발행**

* **보관된 이벤트 기록은 장애 또는 특정 요구사항에 따라 데이터를 복원하는 데 사용
  (이벤트 로그 기반으로 Roll-back 수행)**
* **1, 2, 3의 과정과 이벤트 기반 복원을 통해 최종적인 데이터의 일관성에 도달하는 것이 EDM**
* 이벤트 주도 아키텍처에서 트랜잭션(트랜잭션의 원자성)을 보장하기 위한 방법
  * 트랜잭션: 모두 성공 OR 모두 실패
  * 로컬 트랜잭션 이용
  * 트랜잭션 로그 이용
  * 이벤트 소싱 (Event Sourcing)

### 이벤트 주도 아키텍처에서 트랜잭션을 보장하기 위한 방법
* 로컬 트랜잭션 이용해 이벤트 발행하기
  * 특정 테이블의 레코드가 갱신될 때 이벤트 테이블에 해당 이벤트 정보를 기록하는 방식
  * 휴먼 에러 가능성 있음
* DB 트랜잭션 로그 기반의 이벤트 발행하기
  * 트랜잭션 로그 마이너가 이벤트 퍼블리셔의 역할을 담당. DBMS의 트랜잭션 로그의 변경을 감지하여 이벤트 발행
* 이벤트 소싱 사용하기
  * 객체의 상태 변화에 대한 일련의 이벤트를 저장함으로써 이벤트의 발행을 보장하는 방식
  * 비즈니스 개체의 현재 상태를 저장하는 대신 상태를 변경하는 **모든 이벤트 내역을 목록으로 저장**

### Summary
* 모놀리식 시스템의 한계 -> MSA 전환
* Cloud 기반 구축 환경의 편리함 + MSA의 장점
* 도입 시 따라오는 문제점, 특히 분산 트랜잭션의 처리 
* **Event Driven MicroService의 고려**
